<!DOCTYPE html>
<html>
  <head>
    <title>Hex</title>
    <script src="d3.v4.min.js"></script>
    <script src="sql.js" ></script>
  </head>
  <body>
    <div id="hex"></div>
    <script>
      var sideLength = 8;
      var gridSpacing = 15;

      var grid = function(){
        this.cells = [{
          x:gridSpacing*sideLength,
          y:gridSpacing*sideLength,
          i:0,
          neighbours = [1,2,3,4,5,6]
        }];
        for (var r = 1; r < sideLength; r++){
          for (var t = 0; t < 6; t++){
            for (var k = 0; k < r; k++){
              cells.push({
                x: gridSpacing*(sideLength + r*Math.cos(t*Math.PI/3) + k * Math.cos((t-2)*Math.PI/3)),
                y: gridSpacing*(sideLength + r*Math.sin(t*Math.PI/3) + k * Math.sin((t-2)*Math.PI/3)),
                i: cells.length,
                neighbours: getAdjacent(r, t, k)
              });
            }
          }
        }

        this.sqdist = function(a, b) {
          return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
        };
        var boundary = [cells[0]];


        function getAt(ring, side, offset){
          return r === 0 ? 0 : 1 + 3*ring*(ring-1) + side*ring + offset;
        }
        function firstInRing(r){
          return getAt(r, 0, 0);
        }
        function lastInRing(r){
          return getAt(r, 5, r-1);
        }
        this.getAdjacent = function(ring,side,offset) {
          // this is the centre
          if (ring === 0) {return [1,2,3,4,5,6]}
          // this is the first node in this ring
          if (offset === 0) { // then i = 1 + 3*r*(r-1)
            return [
                // the next node (above and to the left)
                firstInRing(ring) + 1,
                // the first node in the previous ring (left)
                firstInRing(ring - 1),
                // the first node in the next ring (right)
                firstInRing(ring+1),
                // the last node in this ring (below-left)
                lastInRing(ring), // 3*r*(r+1)
                // the second node in the next ring (above-right)
                firstInRing(ring+1) + 1, // 2 + 3*r*(r+1)
                // the last node in the next ring (below-right)
                lastInRing(ring+1)
              ];
            }
            // this is the last node in the first ring
            // this is a special case because it's the only
            // last node which is also a corner node
            if (ring === 1 && side === 5){
              return [0,1,5,18,17,16];
            }
            // this is the last node in a ring
            if (side === 5 && offset === ring - 1) { // then i = 3*r*(r+1)
              return [
                lastInRing(ring) - 1, // the previous node (below and to the left)
                lastInRing(ring+1), // the last node in the next ring (right)
                lastInRing(ring+1)-1,// the penultimate node in the next ring (below-right)
                lastInRing(ring-1),// the last node in the previous ring (left)
                firstInRing(ring-1),// the first node in the previous ring (above-left)
                firstInRing(ring)// the first node in this ring (above-right)
              ]
            }
            if (offset === 0){
              return [
                getAt(ring, side, 1), // next (left)
                getAt(ring, side-1, ring-1),// previous (below-right)
                getAt(ring-1, side, 0),// inside same corner (below-left)
                getAt(ring+1, side, 0),// outside same corter (above-right)
                getAt(ring+1, side-1, ring),// outside same corner minus 1 (right)
                getAt(ring+1, side, 1)// outside same corner plus 1 (above-left)
              ];
            }
            return [
              getAt(ring, side, offset+1),
              getAt(ring, side, offset-1),
              getAt(ring+1, side, offset),
              getAt(ring+1, side, offset+1),
              getAt(ring-1, side, offset),
              getAt(ring-1, side, offset-1),
            ];
        }

        this.occupyNearest = function(p) {
          var minDist = 1000000;
          var d;
          var candidate = null;
          for(var i = 0; i < this.cells.length; i++) {
            if(!this.cells[i].occupied && ( d = this.sqdist(p, this.cells[i])) < minDist) {
              minDist = d;
              candidate = this.cells[i];
            }
          }
          if (candidate) candidate.occupied = true;
          return candidate;
        }
        return this;
      }();
      var svg = d3.select('#hex')
        .append('svg')
        .attr('width', 2* gridSpacing*sideLength)
        .attr('height', 2* gridSpacing*sideLength);
      svg.selectAll(".point")
        .data(grid.cells)
        .enter()
        .append('circle')
        .attr('cx', function(d){return d.x})
        .attr('cy', function(d){return d.y})
        .attr('r', 4)
        .style('fill', 'grey')
        //.on('hover')
        //.append('title')
        //.text(function(d){return d.i});
;

      function updateFakes(fakeNodes){
        grid.clearOccupation();
        fakeNodes.attr('transform', function(d){
          var nearest = grid.occupyNearest(d);
          d.fakeLocation = nearest;
          return 'translate('+nearest.x+','+nearest.y+') scale('+gridSpacing/2+') rotate(30) ';
        });
        svg.selectAll('.link')
      }

      function updateFakeLinks(links){
        links
          .attr('x1', function(d){return d.x})
          .attr('y1', function(d){return d.y})
          .attr('x2', function(d){return d.fakeLocation.x})
          .attr('y2', function(d){return d.fakeLocation.y});
      }

      function updateRealLinks(links){
        links
          .attr('x1', function(d){return d.source.x})
          .attr('y1', function(d){return d.source.y})
          .attr('x2', function(d){return d.target.x})
          .attr('y2', function(d){return d.target.y});
      }

      function startForce(data, db){
        var actualNodes = svg.selectAll('.realNode').data(data)
          .enter().append('circle')
          .attr('r', 4)
          .attr('cx', function(d){return isNaN(d.x) ? 0 : d.x })
          .attr('cy', function(d){return isNaN(d.y) ? 0 : d.y })
          .style('fill', 'red');
        var fakeNodes = svg.selectAll('.fakeNode').data(data)
          .enter().append('polygon')
          .attr('points', '1,0 0.5,0.866 -0.5,0.866 -1,0 -0.5,-0.866 0.5,-0.866')
          .style('fill', 'rgba(0,0,0,0.2)');
        updateFakes(fakeNodes);
        var fakeLinks = svg.selectAll('.fakelink').data(data)
          .enter().append('line').attr('class', 'fakelink')
          .style('stroke', 'black')
          .style('stroke-width', '1.5');
        updateFakeLinks(fakeLinks);
      };

      var xhr = new XMLHttpRequest();
      xhr.open('GET', 'data.db', true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = function(e) {
        var uInt8Array = new Uint8Array(this.response);
        var db = new SQL.Database(uInt8Array);
        var statement = db.prepare(
          "SELECT * from boroughs " +
          "JOIN locations ON boroughs.id = locations.id " +
          "ORDER BY "+
          "(locations.long-51.508)*(locations.long-51.508)"
          +"+(locations.lat-0.1)*(locations.lat-0.1)"
          +" ASC "
           //+ "LIMIT 50"
        );
        var projection = d3.geoMercator()
          .scale(sideLength*gridSpacing*150)
          .center([-0.1, 51.5085300])
          .translate([gridSpacing*sideLength,gridSpacing*sideLength]);
        var data = [];
        while(statement.step()){
          var result = statement.getAsObject();
          result.desiredLocation = projection([result.long, result.lat]);
          result.x = result.desiredLocation[0];
          result.y = result.desiredLocation[1];
          data.push(result);
        }
        startForce(data, db);
      };
      xhr.send();
    </script>
  </body>
</html>
